### 1. Какое число получится?
```
(+ 2 2)
```
- [ ] 0

- [ ] 1

- [ ] 2

- [ ] 3

- [x] 4

- [ ] 5

### 2. true или false?
```
(= (* 2 2) (+ 2 2))
```
- [x] true

- [ ] false

### 3. Какой будет результат: a, b или c?
```
(first (list 'a 'b 'c))
```
- [x] a

- [ ] b

- [ ] c

### 4. Что будет напечатано: Яблоки или Апельсины?
```
(define apples 5)
(define oranges 6)
(if (< apples oranges)
    (printf "Яблоки")
    (printf "Апельсины"))
```
- [x] Яблоки

- [ ] Апельсины

### 5. Какое число получится?
```
(define (dbl x)
  (* 2 x))

(dbl 2)
```
- [ ] 1

- [ ] 2

- [x] 4

- [ ] 8

### 6. Какое число получится?
```
(define (f x)
  (if (<= x 1)
      1
      (* x (f (- x 1)))))
      
(f 3)
```
- [ ] 1

- [ ] 3

- [x] 6

- [ ] 9

### 7. Какой список получится в итоге?
```
(define (qs xs)
  (if (empty? xs)
      (list )
      (let ((middle (first xs))
            (others (rest xs)))
        (let ((left (filter (lambda (x) (<= x middle)) others)
              (right (filter (lambda (x) (> x middle)) others)))
          (append (qs left) (cons middle (qs right))))))))

(qs (list 4 5 1 2 3))
```
- [ ] 4 5 1 2 3

- [x] 1 2 3 4 5

- [ ] 5 4 3 2 1

- [ ] 3 2 1 5 4

## Поздравляю! Вы изучили Лисп! :-)

Ответ последнее задание: мы реализовали алгоритм сортировки quicksort. Выбирается первый элемент списка как "средний"; все меньшие его элементы отфильтровываются в левый список, а все большие элементы в правый список. Алгоритм сортировки рекурсивно вызывается на левый список, результату добавляется "средний" элемент, и результат рекурсии для правого списка.

["Как Lisp стал языком программирования для Бога"](https://habr.com/ru/articles/428229/)
